<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>matthew&#39;s notes</title>
    <description>日常记录，技术笔记</description>
    <link>http://taigetco.github.io//</link>
    <atom:link href="http://taigetco.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Spark RPC</title>
        <description>&lt;p&gt;为什么会选择写Spark RPC，由于工作需要一直关注Spark的dev mail. Spark RPC的实现从之前依赖Akka Actor到抽象出统一的RPC interface, 最后现在基于netty自己开发，一直都觉得很好奇．&lt;/p&gt;

&lt;h3 id=&quot;spark-rpc-interface&quot;&gt;统一的Spark RPC interface&lt;/h3&gt;

&lt;p&gt;在Spark Core中依赖Akka，使得外围框架必需使用同一版本的Akka, 灵活性大大降低，抽象出Spark RPC interface，可以通过反射使用Akka, 避免对它的依赖，一旦有了统一的RPC interface, 可以使用其他不同的框架实现，如netty.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类Actor的接口&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RpcAddress，一对host和post, 代表一个RpcEnv&lt;/li&gt;
  &lt;li&gt;RpcEndpointAddress 包含一个RpcAddress和name, 表示在某个RpcEnv上的RpcEndpoint, name只保证在RpcEnv上的唯一性．&lt;/li&gt;
  &lt;li&gt;RpcCallContext线程安全类，用在RpcEndpoint中的receiveAndReply中可以使RpcEndpoint异步处理消息发送reply&lt;/li&gt;
  &lt;li&gt;RpcEndpoint 类似Actor, 根据消息触发不同功能，life-cycle: constructor -&amp;gt; onStart -&amp;gt; receive* -&amp;gt; onStop, receive可以并发调用，如果想让receive线程安全，使用ThreadSafeRpcEndpoint&lt;/li&gt;
  &lt;li&gt;RpcEnv实现整个Rpc逻辑，注册RpcEndpoint, 管理RpcEndpoint和RpcEndpointRef, 负责分发数据到RpcEndpoint&lt;/li&gt;
  &lt;li&gt;RpcEndpointRef是RpcEndpoint的远程引用，提供send/ask方法，向RpcEndpoint发送数据，简单点实际是一个客户端，只是标注要发往那个RpcEndpoint&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;和Actor的异同&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程安全性：Actor是一个有状态，receive一次只能处理一条消息，不能并行执行．对于使用Actor实现Rpc interface, 不需要保证线程安全性，synchronize完全不需要，Akka已经保证．但这个设计也有不妥之处，假设一个事件RpcEndpoint需要处理很长时间，后续的消息延迟就会很高，响应变慢．通常处理办法都是开一个线程池来处理，对于RpcEndpoint的状态的更新又会牵涉到synchronize来保证线程安全性．&lt;/li&gt;
  &lt;li&gt;在RpcEndpoint中添加方法&lt;code class=&quot;highlighter-rouge&quot;&gt;def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit]&lt;/code&gt;使异步处理消息成为可能, 从而使RpcEndpoint可以并行处理消息.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RpcCallContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendFailure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;senderAddress&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RpcAddress&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;异常处理，Actor中有SupervisorStrategy来负责异常处理，Non-fatal throwables会回传给sender, 由sender来判断处理逻辑．&lt;/li&gt;
  &lt;li&gt;隔离事件处理逻辑，&lt;code class=&quot;highlighter-rouge&quot;&gt;RpcEndpointRef&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;ask&lt;/code&gt;必须发送到&lt;code class=&quot;highlighter-rouge&quot;&gt;RpcEndpoint&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;receiveAndReply&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;才会发送到&lt;code class=&quot;highlighter-rouge&quot;&gt;receive&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;netty&quot;&gt;Netty具体实现&lt;/h3&gt;

&lt;p&gt;来看一下Akka里面是如何解决这一问题，而问什么在Spark中解决起来比较麻烦&lt;/p&gt;

&lt;p&gt;来看一下Akka里面是如何解决这一问题，而问什么在Spark中解决起来比较麻烦&lt;/p&gt;

</description>
        <pubDate>Wed, 10 Feb 2016 05:21:36 +0800</pubDate>
        <link>http://taigetco.github.io//spark/design/2016/02/10/spark-rpc/</link>
        <guid isPermaLink="true">http://taigetco.github.io//spark/design/2016/02/10/spark-rpc/</guid>
      </item>
    
      <item>
        <title>Volatile笔记整理</title>
        <description>&lt;p&gt;其实网上已经由很多对java volatile的深入解析，之前也细读过，但始终觉得比较凌乱，也许是脑子理解问题．这里把自己所理解的东西写出来，当是对volatile的一个总结．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Volatile在JMM里面定义两个语义&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不能重排&lt;/li&gt;
  &lt;li&gt;保证data对所有线程可见&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;非线程安全&lt;/strong&gt;
Volatile变量可以atomic read和atomic write, 但多个steps合在一起时，不是线程安全，比如read/modify/write, 也就是说volatile_var = volatile_var + 1线程不安全．&lt;/p&gt;

&lt;p&gt;在JVM中，对volatile的堆变量的写操作会添加一条汇编指令，参考openJDK的x86_64.ad：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
    lock addl $0x0,(%esp);
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这条指令明显是一个空操作，相当于一个内存屏障，保证lock的前后指令不会重排序，且volatile变量对其他线程的可见性．&lt;/p&gt;

&lt;p&gt;参考intel最新的Intel® 64 and IA-32 Architectures Software Developer’s Manual [5]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For the Intel486 and Pentium processors, the LOCK# signal is always asserted on the bus during a LOCK operation, even if the area of memory being locked is cached in the processor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;For the P6 and more recent processor families, if the area of memory being locked during a LOCK operation is cached in the processor that is performing the LOCK operation as write-back memory and is completely contained in a cache line, the processor may not assert the LOCK# signal on the bus. Instead, it will modify the memory location internally and allow it’s cache coherency mechanism to ensure that the operation is carried out atomically. This operation is called “cache locking.” The cache coherency mechanism automatically prevents two or more processors that have cached the same area of memory from simultaneously modifying data in that area.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以在最新的处理器中，遇到LOCK指令，thread的cache会被更改，并且数据会被写回主存，这个操作一定是原子操作，那么如何使得其他处理器的缓存失效呢&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When operating in an MP system, IA-32 processors (beginning with the Intel486 processor) and Intel 64 processors have the ability to snoop other processor’s accesses to system memory and to their internal caches. They use this snooping ability to keep their internal caches consistent both with system memory and with the caches in other processors on the bus. For example, in the Pentium and P6 family processors, if through snooping one processor detects that another processor intends to write to a memory location that it currently has cached in shared state, the snooping processor will invalidate its cache line forcing it to perform a cache line fill the next time it accesses the same memory location.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Beginning with the P6 family processors, if a processor detects (through snooping) that another processor is trying to access a memory location that it has modified in its cache, but has not yet written back to system memory, the snooping processor will signal the other processor (by means of the HITM# signal) that the cache line is held in modified state and will preform an implicit write-back of the modified data. The implicit write-back is transferred directly to the initial requesting processor and snooped by the memory controller to assure that system memory has been updated. Here, the processor with the valid data may pass the data to the other processors without actually writing it to system memory; however, it is the responsibility of the memory controller to snoop this operation and update memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在此再详细说下LOCK操作，LOCK操作的数据不在cache line或则数据大小操作一个cache line的时候，此时LOCK操作同样会锁住系统总线，此时这是个performance hit 操作，当然发生的概率比较低．Volatile中的lock是不会发生以上两种情况的．在最新的处理器中，更新主存已经不是通过简单的CPU写回策略进行的了，而是处理器之间直接传送有效数据，由内存管理器负责主存的更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种，compiler和cpu. 以下只讨论compiler的重排序．下面这个例子定义６个field, 用PrintAssembly查看JIT生成的汇编:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestJIT&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//10000循环，没有触发C2 compilation&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00007fe18910b297: mov    DWORD PTR [r10+0x68],r11d
                                                ;*putstatic field1
                                                ; - TestJIT::assign@3 (line 13)

0x00007fe18910b29b: mov    DWORD PTR [r10+0x7c],r9d  ;*putstatic field6
                                                ; - TestJIT::assign@34 (line 18)

0x00007fe18910b29f: mov    DWORD PTR [r10+0x78],ecx  ;*putstatic field5
                                                ; - TestJIT::assign@27 (line 17)

0x00007fe18910b2a3: mov    DWORD PTR [r10+0x74],ebx  ;*putstatic field4
                                                ; - TestJIT::assign@21 (line 16)

0x00007fe18910b2a7: mov    DWORD PTR [r10+0x70],esi  ;*putstatic field3
                                                ; - TestJIT::assign@15 (line 15)

0x00007fe18910b2ab: mov    DWORD PTR [r10+0x6c],r8d  ;*putstatic field2
                                                ; - TestJIT::assign@9 (line 14)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到compiler把field[1-6]的赋值，重排序成field[1,6,5,4,3,2].&lt;/p&gt;

&lt;p&gt;当把filed1和field6加上volatile后，生成的汇编如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00007f29d910b197: mov    DWORD PTR [r10+0x68],r11d
                                                ;*putstatic field1
                                                ; - TestJIT::assign@3 (line 13)

0x00007f29d910b19b: mov    DWORD PTR [r10+0x6c],esi  ;*putstatic field2
                                                ; - TestJIT::assign@9 (line 14)

0x00007f29d910b19f: mov    DWORD PTR [r10+0x78],r9d  ;*putstatic field5
                                                ; - TestJIT::assign@27 (line 17)

0x00007f29d910b1a3: mov    DWORD PTR [r10+0x74],ecx  ;*putstatic field4
                                                ; - TestJIT::assign@21 (line 16)

0x00007f29d910b1a7: mov    DWORD PTR [r10+0x70],ebx
0x00007f29d910b1ab: mov    DWORD PTR [r10+0x7c],r8d
0x00007f29d910b1af: lock add DWORD PTR [rsp],0x0  ;*putstatic field6
                                                ; - TestJIT::assign@34 (line 18)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到中间没有加volatile的field[2,3,4,5]，已经被compiler重排序, 而field1和field6还是在头和尾，这里还有一点比较有意思field1的lock add内存屏障已经被优化掉，只要field1和field6不重排，field1的volatile可以省略掉．&lt;/p&gt;

&lt;p&gt;当把filed1和field6改成AtomicInteger, 使用lazySet进行赋值时，其汇编如下，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00007fa1dd112060: mov    DWORD PTR [rsp-0x14000],eax
0x00007fa1dd112067: push   rbp
0x00007fa1dd112068: sub    rsp,0x10           ;*synchronization entry
                                                ; - TestJIT::assign@-1 (line 13)

0x00007fa1dd11206c: mov    r10d,esi
0x00007fa1dd11206f: shl    r10d,1             ;*ishl
                                                ; - TestJIT::assign@5 (line 13)

0x00007fa1dd112072: mov    r11,0x78c7dab20    ;   {oop(a &#39;java/lang/Class&#39; = &#39;TestJIT&#39;)}
0x00007fa1dd11207c: mov    r8d,DWORD PTR [r11+0x68]  ;*getstatic field1
                                                ; - TestJIT::assign@0 (line 13)

0x00007fa1dd112080: test   r8d,r8d
0x00007fa1dd112083: je     0x00007fa1dd1120d1
0x00007fa1dd112085: mov    DWORD PTR [r12+r8*8+0xc],r10d
                                                ;*invokevirtual putOrderedInt
                                                ; - java.util.concurrent.atomic.AtomicInteger::lazySet@8 (line 110)
                                                ; - TestJIT::assign@6 (line 13)

0x00007fa1dd11208a: mov    r10d,DWORD PTR [r11+0x6c]
                                                ;*getstatic field6
                                                ; - TestJIT::assign@33 (line 18)

0x00007fa1dd11208e: mov    ebp,esi
0x00007fa1dd112090: shl    ebp,0x6            ;*ishl
                                                ; - TestJIT::assign@39 (line 18)

0x00007fa1dd112093: mov    r9d,esi
0x00007fa1dd112096: shl    r9d,0x2
0x00007fa1dd11209a: mov    DWORD PTR [r11+0x70],r9d  ;*putstatic field2
                                                ; - TestJIT::assign@12 (line 14)

0x00007fa1dd11209e: mov    r9d,esi
0x00007fa1dd1120a1: shl    r9d,0x5
0x00007fa1dd1120a5: mov    DWORD PTR [r11+0x7c],r9d  ;*putstatic field5
                                                ; - TestJIT::assign@30 (line 17)

0x00007fa1dd1120a9: mov    r9d,esi
0x00007fa1dd1120ac: shl    r9d,0x4
0x00007fa1dd1120b0: mov    DWORD PTR [r11+0x78],r9d  ;*putstatic field4
                                                ; - TestJIT::assign@24 (line 16)

0x00007fa1dd1120b4: shl    esi,0x3
0x00007fa1dd1120b7: mov    DWORD PTR [r11+0x74],esi  ;*putstatic field3
                                                ; - TestJIT::assign@18 (line 15)

0x00007fa1dd1120bb: test   r10d,r10d
0x00007fa1dd1120be: je     0x00007fa1dd1120e5
0x00007fa1dd1120c0: mov    DWORD PTR [r12+r10*8+0xc],ebp
                                                ;*invokevirtual putOrderedInt
                                                ; - java.util.concurrent.atomic.AtomicInteger::lazySet@8 (line 110)
                                                ; - TestJIT::assign@40 (line 18)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;没有添加任何内存屏障(lock add, mfence), 只保证field1和field6的顺序，不会重排，&lt;/p&gt;

&lt;p&gt;[1] http://stackoverflow.com/questions/7805192/is-a-volatile-int-in-java-thread-safe&lt;br /&gt;
[2] http://codingcat.me/2015/05/09/big-brain-hole/&lt;br /&gt;
[3] http://www.infoq.com/cn/articles/ftf-java-volatile&lt;br /&gt;
[4] http://www.infoq.com/cn/articles/zzm-java-hsdis-jvm&lt;br /&gt;
[5] Intel® 64 and IA-32 Architectures Software Developer’s Manual&lt;br /&gt;
[6] http://jpbempel.blogspot.com/2013/05/volatile-and-memory-barriers.html&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jun 2015 19:21:29 +0800</pubDate>
        <link>http://taigetco.github.io//java/concurrency/2015/06/09/java-volatile/</link>
        <guid isPermaLink="true">http://taigetco.github.io//java/concurrency/2015/06/09/java-volatile/</guid>
      </item>
    
  </channel>
</rss>
